{"fragment_id": "F001", "resource_id": "R001", "uv_id": "AI09", "fragment_type": "section", "section_title": "Linear Programming (Contemporary Mathematics)", "start_char": 0, "end_char": 642, "text": "Linear programming is a mathematical technique used to maximize or minimize a linear function subject to a set of linear constraints.  \nThe objective function represents the quantity being optimized, such as profit or cost, and the constraints restrict the values of the variables.  \nHistorically, linear programming was used during World War II to allocate resources efficiently in military logistics, and today businesses use it to manage production and budgets.  \nA linear programming problem consists of an objective function and a system of linear inequalities that define a feasible region; the solution lies at a corner of this region.", "token_count": 98}
{"fragment_id": "F002", "resource_id": "R002", "uv_id": "AI09", "fragment_type": "section", "section_title": "Systems of Linear Inequalities in Two Variables", "start_char": 0, "end_char": 545, "text": "This section introduces systems of linear inequalities in two variables and explains how to solve them by graphing each inequality and identifying the double-shaded region where all inequalities overlap.  \nBy shading the solutions of individual inequalities on the coordinate plane, we can visualize the feasible region that satisfies all constraints simultaneously.  \nSuch systems arise in real\u2011life problems where multiple conditions must be met, and graphing helps illustrate the solution set when solving applications involving inequalities.", "token_count": 75}
{"fragment_id": "F003", "resource_id": "R003", "uv_id": "AI09", "fragment_type": "section", "section_title": "Systems of Linear Equations in Two Variables", "start_char": 0, "end_char": 424, "text": "A system of linear equations in two variables can be solved by graphing, substitution, or elimination.  \nEach solution to the system is an ordered pair that makes both equations true simultaneously, and geometrically this corresponds to the intersection point of two lines.  \nReal-world applications include determining the quantities of produce purchased at a farmers market or finding the point where two cost curves meet.", "token_count": 64}
{"fragment_id": "F004", "resource_id": "R004", "uv_id": "AI09", "fragment_type": "section", "section_title": "Graph Basics", "start_char": 0, "end_char": 469, "text": "Graphs are mathematical structures consisting of vertices and edges that model objects and the connections between them.  \nIn a simple graph, edges connect distinct vertices and there is at most one edge between any pair of vertices, while a multigraph allows multiple edges and loops that connect a vertex to itself.  \nExamples include bus routes, social networks, and computer networks, where vertices represent stops or people and edges represent links between them.", "token_count": 72}
{"fragment_id": "F005", "resource_id": "R005", "uv_id": "AI09", "fragment_type": "section", "section_title": "Graph Structures", "start_char": 0, "end_char": 498, "text": "Graph theory is used to model complex networks such as functional brain networks, and the degree of a vertex\u2014the number of edges incident to it\u2014affects the network\u2019s resilience.  \nIn neuroscience, higher\u2011degree vertices help ensure that the network remains connected even when some vertices are damaged or removed, whereas lower\u2011degree networks are more susceptible to disconnection.  \nUnderstanding these structural properties helps researchers analyze robustness and failure in networked systems.", "token_count": 68}
{"fragment_id": "F006", "resource_id": "R006", "uv_id": "AI09", "fragment_type": "section", "section_title": "Comparing Graphs", "start_char": 0, "end_char": 451, "text": "Two different drawings of a network may actually represent the same graph if they have the same set of vertices connected in the same way.  \nGraph isomorphism occurs when one graph can be transformed into another simply by relabeling vertices without changing the adjacency relationships.  \nTo determine whether graphs are isomorphic, we check that they have the same number of vertices and edges and that corresponding vertices have matching degrees.", "token_count": 70}
{"fragment_id": "F007", "resource_id": "R007", "uv_id": "AI09", "fragment_type": "section", "section_title": "Hamilton Cycles", "start_char": 0, "end_char": 410, "text": "A Hamilton cycle is a circuit in a graph that visits every vertex exactly once and returns to the starting vertex.  \nThese cycles originated in recreational puzzles\u2014such as Hamilton\u2019s Icosian game\u2014and have become important in applications like routing and scheduling.  \nDetermining whether a Hamilton cycle exists in a graph is a fundamental problem in graph theory and has connections to NP\u2011complete problems.", "token_count": 62}
{"fragment_id": "F008", "resource_id": "R008", "uv_id": "AI09", "fragment_type": "section", "section_title": "Traveling Salesperson Problem", "start_char": 0, "end_char": 517, "text": "The traveling salesperson problem asks for the shortest possible circuit that visits every city exactly once and returns to the starting city.  \nOne way to solve it is the brute\u2011force method, which enumerates all possible tours and chooses the best; this guarantees an optimal solution but is computationally expensive.  \nGreedy algorithms offer faster but approximate solutions by making locally optimal choices at each step, highlighting the trade\u2011off between exactness and efficiency in combinatorial optimization.", "token_count": 74}
{"fragment_id": "F009", "resource_id": "R009", "uv_id": "AI09", "fragment_type": "section", "section_title": "Trees", "start_char": 0, "end_char": 366, "text": "A tree is a connected graph with no cycles, meaning there is exactly one path between any two vertices.  \nTrees often represent hierarchical structures such as family trees, computer file systems, and organizational charts.  \nBecause trees are acyclic and connected, they are useful in spanning and search algorithms, enabling efficient traversal of data structures.", "token_count": 54}
{"fragment_id": "F010", "resource_id": "R010", "uv_id": "AI09", "fragment_type": "section", "section_title": "Euler Circuits", "start_char": 0, "end_char": 395, "text": "An Euler circuit is a closed walk that travels every edge of a graph exactly once and returns to its starting vertex.  \nThe existence of such a circuit depends on the graph being connected and having all vertices of even degree.  \nThis concept underlies the Chinese postman problem, which seeks the most efficient route for a mail carrier to traverse every street without unnecessary repetition.", "token_count": 65}
{"fragment_id": "F011", "resource_id": "R011", "uv_id": "AI09", "fragment_type": "section", "section_title": "Introduction to Data Structures and Algorithms", "start_char": 0, "end_char": 444, "text": "In computer science, data types provide abstractions that allow us to model complex objects by grouping simpler pieces of data.  \nFor example, strings combine individual characters into a sequence that can represent text; these abstractions enable programmers to manipulate and store information efficiently.  \nUnderstanding data types and data structures sets the foundation for designing algorithms that process and organize data effectively.", "token_count": 61}
{"fragment_id": "F012", "resource_id": "R012", "uv_id": "AI09", "fragment_type": "section", "section_title": "Algorithmic Paradigms", "start_char": 0, "end_char": 442, "text": "The divide\u2011and\u2011conquer paradigm solves a problem by breaking it into smaller subproblems, recursively solving these subproblems, and combining their solutions to form the overall answer.  \nA classic example is binary search: the algorithm repeatedly divides a sorted list in half and looks for the target value in the appropriate half.  \nMany efficient algorithms, such as quicksort and merge sort, are based on divide\u2011and\u2011conquer techniques.", "token_count": 64}
{"fragment_id": "F013", "resource_id": "R013", "uv_id": "AI09", "fragment_type": "section", "section_title": "Sample Algorithms by Problem", "start_char": 0, "end_char": 429, "text": "Some computational problems have canonical solutions.  \nFor instance, sequential search examines each element in a list until it finds the target, while binary search uses the sorted order of the data to eliminate half of the remaining elements at each step, leading to much faster performance.  \nUnderstanding these sample algorithms and their time complexities helps programmers choose the right tool for the problem they face.", "token_count": 65}
{"fragment_id": "F014", "resource_id": "R014", "uv_id": "AI09", "fragment_type": "section", "section_title": "Combinatorial Optimization (18.453)", "start_char": 0, "end_char": 630, "text": "MIT\u2019s course on combinatorial optimization covers a wide range of topics including cardinality bipartite matching, assignment problems, polyhedral combinatorics, maximum flow and minimum cut, the ellipsoid algorithm, matroids, arborescences, and the traveling salesperson problem.  \nStudents learn how to model combinatorial problems, analyze polytopes arising from linear programming formulations, and design algorithms such as network flow algorithms and matroid intersection.  \nThe course also introduces approximation algorithms for NP\u2011hard problems and provides insight into theoretical and practical aspects of optimization.", "token_count": 78}
{"fragment_id": "F015", "resource_id": "R015", "uv_id": "AI09", "fragment_type": "section", "section_title": "Integer Programming and Combinatorial Optimization (15.083J)", "start_char": 0, "end_char": 543, "text": "This MIT course provides a comprehensive introduction to integer programming and combinatorial optimization.  \nOrganized into four parts, it covers formulations and relaxations of discrete optimization problems, the algebra and geometry of integer optimization, exact algorithms and cutting plane methods, and applications of heuristics and approximation algorithms.  \nTopics include complexity theory, duality, lattice and algebraic geometry methods, robust discrete optimization, and the design of approximation schemes for NP\u2011hard problems.", "token_count": 68}
