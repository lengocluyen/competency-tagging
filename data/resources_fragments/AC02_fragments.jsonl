{"fragment_id": "F901", "resource_id": "R901", "uv_id": "AC02", "fragment_type": "section", "section_title": "Foundations of Software Engineering", "start_char": 0, "end_char": 631, "text": "This is a foundation subject in modern software development techniques for engineering and information technology. The design and development of component-based software (using C# and .NET) is covered; data structures and algorithms for modeling, analysis, and visualization; basic problem-solving techniques; web services; and the management and maintenance of software. Includes a treatment of topics such as sorting and searching algorithms; and numerical simulation techniques. Foundation for in-depth exploration of image processing, computational geometry, finite element methods, network methods and e-business applications.", "token_count": 81}
{"fragment_id": "F902", "resource_id": "R902", "uv_id": "AC02", "fragment_type": "section", "section_title": "Software Engineering for Web Applications", "start_char": 0, "end_char": 647, "text": "6.171 is a course for students who already have some programming and software engineering experience. The goal is to give students some experience in dealing with those challenges that are unique to Internet applications, such as concurrency; unpredictable load; security risks; opportunity for wide-area distributed computing; creating a reliable and stateful user experience on top of unreliable connections and stateless protocols; extreme requirements and absurd development schedules; requirements that change mid-way through a project, sometimes because of experience gained from testing with users; user demands for a multi-modal interface.", "token_count": 89}
{"fragment_id": "F903", "resource_id": "R903", "uv_id": "AC02", "fragment_type": "section", "section_title": "Software Engineering Concepts", "start_char": 0, "end_char": 649, "text": "This is a reading and discussion subject on issues in the engineering of software systems and software development project design. It includes the present state of software engineering, what has been tried in the past, what worked, what did not, and why. Topics may differ in each offering, but will be chosen from: the software process and lifecycle; requirements and specifications; design principles; testing, formal analysis, and reviews; quality management and assessment; product and process metrics; COTS and reuse; evolution and maintenance; team organization and people management; and software engineering aspects of programming languages.", "token_count": 94}
{"fragment_id": "F904", "resource_id": "R904", "uv_id": "AC02", "fragment_type": "section", "section_title": "Laboratory in Software Engineering", "start_char": 0, "end_char": 413, "text": "This course introduces concepts and techniques relevant to the production of large software systems. Students are taught a programming method based on the recognition and description of useful abstractions. Topics include modularity, specification, data abstraction, object modeling, design patterns, and testing. Students complete several programming projects of varying size, working individually and in groups.", "token_count": 54}
{"fragment_id": "F905", "resource_id": "R905", "uv_id": "AC02", "fragment_type": "section", "section_title": "Performance Engineering of Software Systems", "start_char": 0, "end_char": 367, "text": "6.172 is an 18‑unit class that provides a hands-on, project‑based introduction to building scalable and high‑performance software systems. Topics include performance analysis, algorithmic techniques for high performance, instruction‑level optimizations, caching optimizations, parallel programming, and building scalable systems. The course programming language is C.", "token_count": 43}
{"fragment_id": "F906", "resource_id": "R906", "uv_id": "AC02", "fragment_type": "section", "section_title": "Software Construction", "start_char": 0, "end_char": 447, "text": "6.005 Software Construction introduces fundamental principles and techniques of software development — how to write software that is safe from bugs, easy to understand, and ready for change. The course includes problem sets and a final project. Important topics include specifications and invariants; testing; abstract data types; design patterns for object‑oriented programming; concurrent programming and concurrency; and functional programming.", "token_count": 59}
{"fragment_id": "F907", "resource_id": "R907", "uv_id": "AC02", "fragment_type": "section", "section_title": "Software Construction Assignments", "start_char": 0, "end_char": 409, "text": "The assignments page advises students to review the 6.005 Getting Started page, as well as the specific Getting Started pages for Java and the Eclipse FQA, before attempting the assignments. The assignments include Problem Set 0: Turtle Graphics; Problem Set 1: Tweet Tweet; Problem Set 2: Poetic Walks; Problem Set 3: Expressivo; Problem Set 4: Multiplayer Minesweeper; and a final project: ABC Music Player.", "token_count": 64}
{"fragment_id": "F908", "resource_id": "R908", "uv_id": "AC02", "fragment_type": "section", "section_title": "Performance Engineering Quizzes", "start_char": 0, "end_char": 284, "text": "The quizzes page lists practice quizzes and their solutions for the Performance Engineering of Software Systems course. It includes Practice Quiz 1 and its solutions, Practice Quiz 2 and its solutions, Practice Quiz 3 with no solutions provided, and Practice Quiz 4 and its solutions.", "token_count": 45}
{"fragment_id": "F909", "resource_id": "R909", "uv_id": "AC02", "fragment_type": "section", "section_title": "9.1 Software Engineering Fundamentals", "start_char": 0, "end_char": 926, "text": "This section introduces software engineering along with the challenges associated with the creation and evolution of software. Learning objectives include describing the intent of software engineering and how it relates to computer science, recognizing various categories of software, and identifying the skills required for a software engineer. The IEEE defines software engineering as the application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software. The text explains that software engineering relies on methodologies, processes, methods, and tools used to develop and maintain quality software while optimizing resources such as time and cost. It emphasizes selecting and tailoring processes, methods, and tools to meet project goals and discusses why software engineering cannot be fully automated, highlighting the importance of team roles and communication.", "token_count": 127}
{"fragment_id": "F910", "resource_id": "R910", "uv_id": "AC02", "fragment_type": "section", "section_title": "9.2 Software Engineering Process", "start_char": 0, "end_char": 920, "text": "This section describes the phases of a software development process and their purposes, examining popular traditional prescriptive and Agile software process models. Software engineering processes are compared to recipes that provide structured approaches to creating software. The generic software engineering process model includes framework activities—such as inception, elaboration, construction, and deployment—and umbrella activities like training, risk management, configuration management, quality management, architecture management, and security management. The section discusses how framework activities and task sets are tailored for each project, and it highlights traditional prescriptive process models (waterfall, prototyping, spiral, rational unified process) which aim to improve efficiency, reduce risk, and increase predictability, while noting that they are often criticized as rigid and inflexible.", "token_count": 114}
{"fragment_id": "F911", "resource_id": "R911", "uv_id": "AC02", "fragment_type": "section", "section_title": "9.3 Special Topics", "start_char": 0, "end_char": 829, "text": "This section explores special topics in software engineering, including software testing, refactoring, design patterns, software tools, software reuse, ethics, and legal aspects. It explains the importance of testing and describes various levels of testing—unit, integration, and system—as well as testing approaches such as acceptance, usability, stress, performance, and security testing. The section discusses testing methodologies: white box testing, where the tester has knowledge of the code; black box testing, which focuses on requirements and functionality without knowledge of the code; and gray box testing, a hybrid of the two. It notes that finding issues early reduces costs, distinguishes verification from validation, and explains that both functional and nonfunctional testing are essential for quality software.", "token_count": 114}
{"fragment_id": "F912", "resource_id": "R912", "uv_id": "AC02", "fragment_type": "section", "section_title": "Ch. 9 Review Questions", "start_char": 0, "end_char": 732, "text": "The review questions page presents a series of multiple-choice and open‑ended questions covering software engineering best practices, the relationship between software engineering and computer science, categories of software, soft skills for software engineers, roles in a software team, the meaning of SDLC, phases of the SDLC, common process models, and topics related to testing and development methodologies such as test‑driven development. It asks students to define verification and validation, identify types of testing (unit, acceptance, performance, stress, usability), explain the purpose of version control systems and integrated development environments, and consider whether open‑source software can be used at no cost.", "token_count": 100}
{"fragment_id": "F913", "resource_id": "R913", "uv_id": "AC02", "fragment_type": "section", "section_title": "Ch. 9 Practice Exercises", "start_char": 0, "end_char": 690, "text": "The practice exercises page provides activities for Chapter 9, asking students to list computer technology areas that software engineers should be familiar with, identify soft skills important for software engineers, categorize software programs as system, application or embedded software, choose an appropriate SDLC model based on a scenario, propose strategies for meeting urgent client needs with incomplete requirements, research DevSecOps and summarize how it differs from DevOps, and analyze research‑based, search‑based, and test‑driven processes (RE, SBSE, TDD) to explain how they improve traditional software engineering processes from a software process improvement perspective.", "token_count": 92}
{"fragment_id": "F914", "resource_id": "R914", "uv_id": "AC02", "fragment_type": "section", "section_title": "Ch. 9 Summary", "start_char": 0, "end_char": 899, "text": "The summary page reviews key concepts from Chapter 9. It emphasizes that software engineering focuses on the effective development of software by addressing practical issues while leveraging theoretical computer science. It notes that software is typically developed in teams and falls into categories such as application, system, and embedded software. The page highlights the importance of software engineering processes, including process frameworks with phases (inception, elaboration, construction, deployment) and crosscutting activities like communication, risk management, configuration management, quality management, and security. It contrasts traditional prescriptive models with Agile models, explains various testing levels and approaches, and discusses tools, design and architectural patterns, refactoring, open‑source software, and the ethical responsibilities of software engineers.", "token_count": 112}
{"fragment_id": "F915", "resource_id": "R915", "uv_id": "AC02", "fragment_type": "section", "section_title": "Reading: Software Development Process", "start_char": 0, "end_char": 966, "text": "This reading defines a software development methodology (or software process) as a division of software development work into distinct phases for better planning and management. It introduces common methodologies such as waterfall, prototyping, iterative and incremental development, spiral development, rapid application development, extreme programming, and various types of agile methodology. It notes that no single framework suits all projects and that process methodologies are implemented to improve productivity and quality. The article mentions the history of the software development life cycle (SDLC), including standards like ISO/IEC 12207, and lists frameworks and approaches introduced from the 1970s to the 2000s. It contrasts traditional life‑cycle models with Agile approaches and outlines typical phases of the software development process, including requirements analysis, design, implementation, testing, integration, deployment, and maintenance.", "token_count": 126}
{"fragment_id": "F916", "resource_id": "R916", "uv_id": "AC02", "fragment_type": "section", "section_title": "Reading: Software Development", "start_char": 0, "end_char": 1157, "text": "This reading explains that software development encompasses programming, documenting, testing, bug fixing, and maintenance activities that create and maintain applications and frameworks. It covers the entire software release life cycle from conception to final product and includes activities such as research, prototyping, modification, reuse, re‑engineering, and maintenance. The article discusses the purposes of software (custom, commercial, personal) and highlights differences between embedded, system, and application software. It describes the need for quality control, which led to the discipline of software engineering. The section outlines stages of the software development life cycle—analyzing the problem, market research, gathering requirements, devising a plan or design, implementation (coding), testing, deployment, and maintenance—and compares structured (waterfall) approaches with more incremental approaches where design, construction, and deployment occur simultaneously. It notes that structured approaches emphasize planning and documentation while incremental approaches emphasize coding, automated tests, and continuous testing.", "token_count": 142}
{"fragment_id": "F917", "resource_id": "R917", "uv_id": "AC02", "fragment_type": "section", "section_title": "About this Site - Intermediate Agile Software Development", "start_char": 0, "end_char": 677, "text": "The About page of Intermediate Agile Software Development explains that the site contains a collection of lectures, assignments, and instructor materials for teaching software engineering or development at an intermediate level. The materials support the ITEC 3870 Software Development course sequence taught at Georgia Gwinnett College and were developed by Cengiz Gunay and Anca Doloc‑Mihu with support from Affordable Learning Georgia grants. It notes other contributors and states that slides are offered under the Creative Commons Attribution‑ShareAlike 4.0 license. The page encourages users to fork the GitHub repository to modify and use the materials in their classes.", "token_count": 97}
