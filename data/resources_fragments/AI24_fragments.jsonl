{"fragment_id": "F001", "resource_id": "R301", "uv_id": "AI24", "fragment_type": "section", "section_title": "Sensor Technologies for Interactive Environments", "start_char": 0, "end_char": 635, "text": "This course is a broad introduction to a host of sensor technologies, illustrated by applications drawn from human–computer interfaces and ubiquitous computing. After reviewing electronics for sensor signal conditioning, the lectures cover the principles and operation of sensor architectures and modalities, including pressure, strain, displacement, proximity, thermal, electric and magnetic fields, optical, acoustic, RF, inertial and bioelectric sensors. Simple sensor processing algorithms and wired and wireless network standards are also discussed. Students complete written assignments, laboratory exercises and a final project.", "token_count": 81}
{"fragment_id": "F002", "resource_id": "R302", "uv_id": "AI24", "fragment_type": "section", "section_title": "Computer System Architecture", "start_char": 0, "end_char": 493, "text": "This course studies the evolution of computer architecture and the factors influencing hardware and software design. Topics include instruction set design; processor micro‑architecture and pipelining; cache and virtual memory organizations; protection and sharing; input/output and interrupts; in‑order and out‑of‑order superscalar architectures; Very Long Instruction Word (VLIW) machines; vector supercomputers; multithreaded architectures; symmetric multiprocessors; and parallel computers.", "token_count": 56}
{"fragment_id": "F003", "resource_id": "R303", "uv_id": "AI24", "fragment_type": "section", "section_title": "Computer System Engineering", "start_char": 0, "end_char": 356, "text": "This class covers topics on the engineering of computer software and hardware systems. Topics include techniques for controlling complexity; strong modularity using client–server design; operating systems; performance; networks; naming; security and privacy; fault‑tolerant systems; atomicity and coordination of concurrent activities; and system recovery.", "token_count": 43}
{"fragment_id": "F004", "resource_id": "R304", "uv_id": "AI24", "fragment_type": "section", "section_title": "Operating System Engineering", "start_char": 0, "end_char": 534, "text": "This course covers the design and implementation of operating systems and their use as a foundation for systems programming. Topics include virtual memory, file systems, threads, context switches, kernels, interrupts, system calls, interprocess communication and coordination, and the interaction between software and hardware. A multi‑processor operating system for RISC‑V, xv6, is used to illustrate these concepts, and laboratory assignments involve extending xv6 to support features such as advanced virtual memory and networking.", "token_count": 72}
{"fragment_id": "F005", "resource_id": "R305", "uv_id": "AI24", "fragment_type": "section", "section_title": "Introduction to Sustainable Energy", "start_char": 0, "end_char": 572, "text": "This class assesses current and potential future energy systems, covering resources, extraction, conversion and end‑use technologies, with emphasis on meeting regional and global energy needs sustainably. Instructors and guest lecturers examine renewable and conventional energy production technologies, energy end‑use practices and alternatives, and consumption practices in different countries. Students learn a quantitative framework to evaluate and analyze energy technology proposals in the context of engineering, political, social, economic and environmental goals.", "token_count": 71}
{"fragment_id": "F006", "resource_id": "R306", "uv_id": "AI24", "fragment_type": "section", "section_title": "MIT Energy Collection Overview", "start_char": 0, "end_char": 573, "text": "MIT researchers and students investigate all aspects of energy, seeking to understand and transform energy systems. They discover new ways of generating and storing energy, from biofuels made from plant waste to high‑capacity batteries for renewable electricity. Researchers design experiments to improve energy efficiency at all scales, from nanostructures and photovoltaic cells to large power plants and smart electrical grids. They also analyze how individuals and nations make energy decisions and forecast the social and environmental consequences of these decisions.", "token_count": 80}
{"fragment_id": "F007", "resource_id": "R307", "uv_id": "AI24", "fragment_type": "section", "section_title": "Computation Structures: Design Trade‑offs and Power Dissipation", "start_char": 0, "end_char": 814, "text": "This lecture discusses optimizing digital systems to make them smaller, faster, higher performance and more energy efficient, noting that improvements often require trade‑offs. It compares the design goals of a high‑end gaming graphics card, which prioritizes performance even at the cost of power consumption, with those of an Apple Watch, which must minimize size and power consumption. The lecture introduces power dissipation as the first optimization topic, explaining static and dynamic power dissipation in CMOS circuits. Static power arises from gate‑oxide tunneling and sub‑threshold conduction as transistors shrink, while dynamic power results from charging and discharging capacitances during switching. Designers must balance these factors to meet power budgets and prevent overheating in modern CPUs.", "token_count": 114}
{"fragment_id": "F008", "resource_id": "R308", "uv_id": "AI24", "fragment_type": "section", "section_title": "Models of Computation", "start_char": 0, "end_char": 775, "text": "This section defines computational models as systems that describe what an algorithm does and how to run it. Examples include physical devices that can run software, programming languages and design specifications. It explains that programming languages are linguistic applications of algorithms and describes high‑level and low‑level languages. Computer architects design hardware models, such as CPUs, with hardware specifications like execution speed or energy use in mind. Examples include the MOS Technology 6502 architecture used in early video game consoles, ARM architectures used in mobile phones, and x86‑64 architectures used in modern personal computers. Hardware models are designed for machine convenience, whereas programming models are designed for human use.", "token_count": 108}
{"fragment_id": "F009", "resource_id": "R309", "uv_id": "AI24", "fragment_type": "section", "section_title": "What Is an Operating System?", "start_char": 0, "end_char": 790, "text": "This section describes an operating system (OS) as the core piece of software that manages and controls the interconnection of hardware and software on a computer. Typical OSs include Windows, macOS and Linux for computers and iOS and Android for mobile devices. The OS mediates between applications and hardware resources such as the CPU, memory, storage, network interfaces and input/output devices. One of the OS’s primary goals is isolation: ensuring that multiple programs running concurrently on the same CPU and memory do not interfere with each other’s execution or data. The section explains that the OS provides mechanisms for resource sharing and outlines design questions related to OS structure, sharing, naming, protection, security, performance, availability and reliability.", "token_count": 117}
{"fragment_id": "F010", "resource_id": "R310", "uv_id": "AI24", "fragment_type": "section", "section_title": "Fundamental OS Concepts", "start_char": 0, "end_char": 623, "text": "This section explains that an operating system manages computer resources and provides services for programs. It acts as an interface between the user and the system, managing memory, files, hardware and software while handling inputs and outputs like keyboards and printers. The section introduces OS components such as process management and threads, memory and address space management, device drivers and I/O devices. It also discusses OS structures, including monolithic designs, layered designs, hardware abstraction layers and microkernels, explaining how each structure organizes the OS and interacts with hardware.", "token_count": 88}
{"fragment_id": "F011", "resource_id": "R311", "uv_id": "AI24", "fragment_type": "section", "section_title": "Processes and Concurrency", "start_char": 0, "end_char": 624, "text": "This section explains that an OS divides tasks into processes and supports concurrency so that multiple tasks can run at the same time. Concurrent processing improves performance when multiple processors execute instructions simultaneously. The section introduces process management and interprocess communication, threads, scheduling and synchronization. It defines a process as an instance of a program in execution and notes that processes have an address space, CPU state and OS resources. It discusses client–server communication, process control blocks and how operating systems manage processes to enable concurrency.", "token_count": 86}
{"fragment_id": "F012", "resource_id": "R312", "uv_id": "AI24", "fragment_type": "section", "section_title": "Memory Management", "start_char": 0, "end_char": 700, "text": "This section discusses memory multiplexing and virtual memory management. It explains that multiple processes and threads share the same hardware, so the OS must multiplex CPU time, memory and devices while ensuring isolation. Isolation mechanisms include user/kernel mode flags, address space boundaries and system call interfaces, which prevent processes from interfering with each other. The section describes time slicing in preemptive multitasking and outlines concepts such as sharing, virtualization and utilization. It notes that virtualization gives an application the illusion of having its own logical memory and distinguishes between full virtualization and guest modification approaches.", "token_count": 95}
{"fragment_id": "F013", "resource_id": "R313", "uv_id": "AI24", "fragment_type": "section", "section_title": "File Systems", "start_char": 0, "end_char": 732, "text": "This section introduces files and file systems. A file is a collection of related information stored on secondary storage; file names include a name and extension. A file system defines file names, stores files on storage devices and retrieves them. Key design issues include per‑file overhead, performance for large files, unpredictable file growth and user‑friendly naming. Directories are special files that map names to files, enabling hierarchical structures. The section discusses file system issues such as disk management, naming and protection, and compares file system architectures like UNIX/Linux inodes and Windows FAT and NTFS. It also highlights high‑level services such as quotas, backups, versioning and encryption.", "token_count": 106}
{"fragment_id": "F014", "resource_id": "R314", "uv_id": "AI24", "fragment_type": "section", "section_title": "Reliability and Security", "start_char": 0, "end_char": 676, "text": "This section notes that an operating system should provide reliability, protection, security and stability. The protection mechanism in an OS regulates access to resources such as memory, processes, files, devices, CPU time and network bandwidth. Protection involves authentication, authorization and access enforcement; authentication verifies a user’s identity, authorization determines what actions the user is permitted to perform and access enforcement controls resource access. The section also discusses security measures such as passwords, badges, two‑factor authentication and access control lists, explaining how these mechanisms help secure an OS and its resources.", "token_count": 90}
{"fragment_id": "F015", "resource_id": "R315", "uv_id": "AI24", "fragment_type": "section", "section_title": "Operating Systems Review Questions", "start_char": 0, "end_char": 418, "text": "This page provides review questions about operating systems. Questions ask students to identify privileged instructions, describe virtualization, compare monolithic and microkernel OS structures, define user and kernel modes, describe scheduling algorithms and explain synchronization mechanisms. These questions reinforce understanding of OS concepts and encourage critical thinking about OS design and functionality.", "token_count": 51}
{"fragment_id": "F016", "resource_id": "R316", "uv_id": "AI24", "fragment_type": "section", "section_title": "I Dream of IoT: Connecting the Physical and Virtual World", "start_char": 0, "end_char": 727, "text": "This article imagines how the Internet of Things (IoT) can improve quality of life through intelligent systems. It describes a scenario in which home sensors detect an unauthorized intruder, alert security and police, activate surveillance cameras and send detailed reports to the homeowner, police and insurance company. The article defines the IoT as a globally interconnected collection of devices, systems and services coordinated manually or automatically to perform useful functions. It notes that smart city initiatives aim to improve efficiency, security and sustainability through interconnected devices and highlights the potential of IoT technologies to empower society through synergistic information collaboration.", "token_count": 100}
{"fragment_id": "F017", "resource_id": "R317", "uv_id": "AI24", "fragment_type": "section", "section_title": "Reading: Computer Network", "start_char": 0, "end_char": 635, "text": "This reading defines a computer network as a telecommunications network where devices such as computers, phones, servers and networking hardware exchange data across cable or wireless media. Network nodes include various devices, and the transmission medium may be wired or wireless. Networks support services like the internet, email, digital audio and video, and the World Wide Web. The page discusses network protocols, network types and applications, explaining that modern networking enables communication between sensors, actuators and computing devices in applications ranging from home automation to industrial control systems.", "token_count": 88}
{"fragment_id": "F018", "resource_id": "R318", "uv_id": "AI24", "fragment_type": "section", "section_title": "Software Engineering Fundamentals", "start_char": 0, "end_char": 723, "text": "This section introduces software engineering and the challenges associated with creating and evolving software. It defines software engineering as the application of a systematic, disciplined and quantifiable approach to developing, operating and maintaining software. The section explains that software engineering involves selecting and tailoring methodologies, processes and tools to develop quality software while optimizing resources like time and cost. It emphasises the importance of choosing the right processes and methods when requirements are changing and many developers are working together and highlights that software engineering cannot be fully automated, making project coordination and alignment critical.", "token_count": 95}
