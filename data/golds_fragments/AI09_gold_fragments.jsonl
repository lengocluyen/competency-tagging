{"uv_id": "AI09", "resource_id": "R001", "fragment_id": "F001", "fragment_type": "section", "section_title": "Linear Programming (Contemporary Mathematics)", "resource_start_char": 0, "resource_end_char": 642, "text": "Linear programming is a mathematical technique used to maximize or minimize a linear function subject to a set of linear constraints.   The objective function represents the quantity being optimized, such as profit or cost, and the constraints restrict the values of the variables.   Historically, linear programming was used during World War II to allocate resources efficiently in military logistics, and today businesses use it to manage production and budgets.   A linear programming problem consists of an objective function and a system of linear inequalities that define a feasible region; the solution lies at a corner of this region.", "gold": [{"competency_id": "GI_C5_3", "competency_uri": "http://gamaizer.ia/ontology#GI_C5_3", "label": "Combinatoire et optimisation", "evidence": {"start": 0, "end": 78, "quote": "Linear programming is a mathematical technique used to maximize or minimize a "}, "evidence_pattern": "linear programming"}], "notes": "", "candidates": ["GI_C1_1", "GI_C4_1", "GI_C2_1", "GI_C5_1", "GI_C5_3"]}
{"uv_id": "AI09", "resource_id": "R002", "fragment_id": "F002", "fragment_type": "section", "section_title": "Systems of Linear Inequalities in Two Variables", "resource_start_char": 0, "resource_end_char": 545, "text": "This section introduces systems of linear inequalities in two variables and explains how to solve them by graphing each inequality and identifying the double-shaded region where all inequalities overlap.   By shading the solutions of individual inequalities on the coordinate plane, we can visualize the feasible region that satisfies all constraints simultaneously.   Such systems arise in real‑life problems where multiple conditions must be met, and graphing helps illustrate the solution set when solving applications involving inequalities.", "gold": [{"competency_id": "GI_C5_3", "competency_uri": "http://gamaizer.ia/ontology#GI_C5_3", "label": "Combinatoire et optimisation", "evidence": {"start": 2, "end": 111, "quote": "is section introduces systems of linear inequalities in two variables and explains how to solve them by graph"}, "evidence_pattern": "inequalit"}], "notes": "", "candidates": ["GI_C1_2", "GI_C2_2", "GI_C5_3", "GI_C1_1"]}
{"uv_id": "AI09", "resource_id": "R003", "fragment_id": "F003", "fragment_type": "section", "section_title": "Systems of Linear Equations in Two Variables", "resource_start_char": 0, "resource_end_char": 424, "text": "A system of linear equations in two variables can be solved by graphing, substitution, or elimination.   Each solution to the system is an ordered pair that makes both equations true simultaneously, and geometrically this corresponds to the intersection point of two lines.   Real-world applications include determining the quantities of produce purchased at a farmers market or finding the point where two cost curves meet.", "gold": [], "notes": "", "candidates": ["GI_C2_1", "GI_C1_1"]}
{"uv_id": "AI09", "resource_id": "R004", "fragment_id": "F004", "fragment_type": "section", "section_title": "Graph Basics", "resource_start_char": 0, "resource_end_char": 469, "text": "Graphs are mathematical structures consisting of vertices and edges that model objects and the connections between them.   In a simple graph, edges connect distinct vertices and there is at most one edge between any pair of vertices, while a multigraph allows multiple edges and loops that connect a vertex to itself.   Examples include bus routes, social networks, and computer networks, where vertices represent stops or people and edges represent links between them.", "gold": [{"competency_id": "GI_C5_3", "competency_uri": "http://gamaizer.ia/ontology#GI_C5_3", "label": "Combinatoire et optimisation", "evidence": {"start": 9, "end": 117, "quote": "e mathematical structures consisting of vertices and edges that model objects and the connections between th"}, "evidence_pattern": "\\bvertices\\b"}], "notes": "", "candidates": ["GI_C2_2", "GI_C1_1", "GI_C1_4", "GI_C2_1", "GI_C5_1"]}
{"uv_id": "AI09", "resource_id": "R005", "fragment_id": "F005", "fragment_type": "section", "section_title": "Graph Structures", "resource_start_char": 0, "resource_end_char": 498, "text": "Graph theory is used to model complex networks such as functional brain networks, and the degree of a vertex—the number of edges incident to it—affects the network’s resilience.   In neuroscience, higher‑degree vertices help ensure that the network remains connected even when some vertices are damaged or removed, whereas lower‑degree networks are more susceptible to disconnection.   Understanding these structural properties helps researchers analyze robustness and failure in networked systems.", "gold": [{"competency_id": "GI_C5_3", "competency_uri": "http://gamaizer.ia/ontology#GI_C5_3", "label": "Combinatoire et optimisation", "evidence": {"start": 0, "end": 65, "quote": "Graph theory is used to model complex networks such as functional"}, "evidence_pattern": "\\bgraph\\b"}], "notes": "", "candidates": ["GI_C2_2", "GI_C1_4", "GI_C2_1", "GI_C1_1"]}
{"uv_id": "AI09", "resource_id": "R006", "fragment_id": "F006", "fragment_type": "section", "section_title": "Comparing Graphs", "resource_start_char": 0, "resource_end_char": 451, "text": "Two different drawings of a network may actually represent the same graph if they have the same set of vertices connected in the same way.   Graph isomorphism occurs when one graph can be transformed into another simply by relabeling vertices without changing the adjacency relationships.   To determine whether graphs are isomorphic, we check that they have the same number of vertices and edges and that corresponding vertices have matching degrees.", "gold": [{"competency_id": "GI_C5_3", "competency_uri": "http://gamaizer.ia/ontology#GI_C5_3", "label": "Combinatoire et optimisation", "evidence": {"start": 28, "end": 133, "quote": "network may actually represent the same graph if they have the same set of vertices connected in the same"}, "evidence_pattern": "\\bgraph\\b"}], "notes": "", "candidates": ["GI_C2_2", "GI_C1_4", "GI_C1_1"]}
{"uv_id": "AI09", "resource_id": "R007", "fragment_id": "F007", "fragment_type": "section", "section_title": "Hamilton Cycles", "resource_start_char": 0, "resource_end_char": 410, "text": "A Hamilton cycle is a circuit in a graph that visits every vertex exactly once and returns to the starting vertex.   These cycles originated in recreational puzzles—such as Hamilton’s Icosian game—and have become important in applications like routing and scheduling.   Determining whether a Hamilton cycle exists in a graph is a fundamental problem in graph theory and has connections to NP‑complete problems.", "gold": [{"competency_id": "GI_C5_3", "competency_uri": "http://gamaizer.ia/ontology#GI_C5_3", "label": "Combinatoire et optimisation", "evidence": {"start": 0, "end": 100, "quote": "A Hamilton cycle is a circuit in a graph that visits every vertex exactly once and returns to the st"}, "evidence_pattern": "\\bgraph\\b"}], "notes": "", "candidates": ["GI_C2_1", "GI_C1_1"]}
{"uv_id": "AI09", "resource_id": "R008", "fragment_id": "F008", "fragment_type": "section", "section_title": "Traveling Salesperson Problem", "resource_start_char": 0, "resource_end_char": 517, "text": "The traveling salesperson problem asks for the shortest possible circuit that visits every city exactly once and returns to the starting city.   One way to solve it is the brute‑force method, which enumerates all possible tours and chooses the best; this guarantees an optimal solution but is computationally expensive.   Greedy algorithms offer faster but approximate solutions by making locally optimal choices at each step, highlighting the trade‑off between exactness and efficiency in combinatorial optimization.", "gold": [{"competency_id": "GI_C5_3", "competency_uri": "http://gamaizer.ia/ontology#GI_C5_3", "label": "Combinatoire et optimisation", "evidence": {"start": 450, "end": 517, "quote": "off between exactness and efficiency in combinatorial optimization."}, "evidence_pattern": "combinatorial"}], "notes": "", "candidates": ["GI_C1_1", "GI_C1_2", "GI_C5_3", "GI_C2_1"]}
{"uv_id": "AI09", "resource_id": "R009", "fragment_id": "F009", "fragment_type": "section", "section_title": "Trees", "resource_start_char": 0, "resource_end_char": 366, "text": "A tree is a connected graph with no cycles, meaning there is exactly one path between any two vertices.   Trees often represent hierarchical structures such as family trees, computer file systems, and organizational charts.   Because trees are acyclic and connected, they are useful in spanning and search algorithms, enabling efficient traversal of data structures.", "gold": [{"competency_id": "GI_C5_3", "competency_uri": "http://gamaizer.ia/ontology#GI_C5_3", "label": "Combinatoire et optimisation", "evidence": {"start": 0, "end": 87, "quote": "A tree is a connected graph with no cycles, meaning there is exactly one path between a"}, "evidence_pattern": "\\bgraph\\b"}], "notes": "", "candidates": ["GI_C1_1"]}
{"uv_id": "AI09", "resource_id": "R010", "fragment_id": "F010", "fragment_type": "section", "section_title": "Euler Circuits", "resource_start_char": 0, "resource_end_char": 395, "text": "An Euler circuit is a closed walk that travels every edge of a graph exactly once and returns to its starting vertex.   The existence of such a circuit depends on the graph being connected and having all vertices of even degree.   This concept underlies the Chinese postman problem, which seeks the most efficient route for a mail carrier to traverse every street without unnecessary repetition.", "gold": [{"competency_id": "GI_C5_3", "competency_uri": "http://gamaizer.ia/ontology#GI_C5_3", "label": "Combinatoire et optimisation", "evidence": {"start": 23, "end": 128, "quote": "losed walk that travels every edge of a graph exactly once and returns to its starting vertex.   The exis"}, "evidence_pattern": "\\bgraph\\b"}], "notes": "", "candidates": ["GI_C2_1", "GI_C1_1"]}
{"uv_id": "AI09", "resource_id": "R011", "fragment_id": "F011", "fragment_type": "section", "section_title": "Introduction to Data Structures and Algorithms", "resource_start_char": 0, "resource_end_char": 444, "text": "In computer science, data types provide abstractions that allow us to model complex objects by grouping simpler pieces of data.   For example, strings combine individual characters into a sequence that can represent text; these abstractions enable programmers to manipulate and store information efficiently.   Understanding data types and data structures sets the foundation for designing algorithms that process and organize data effectively.", "gold": [],"notes": "", "candidates": ["GI_C1_1", "GI_C1_2", "GI_C2_1", "GI_C2_2"]}
{"uv_id": "AI09", "resource_id": "R012", "fragment_id": "F012", "fragment_type": "section", "section_title": "Algorithmic Paradigms", "resource_start_char": 0, "resource_end_char": 442, "text": "The divide‑and‑conquer paradigm solves a problem by breaking it into smaller subproblems, recursively solving these subproblems, and combining their solutions to form the overall answer.   A classic example is binary search: the algorithm repeatedly divides a sorted list in half and looks for the target value in the appropriate half.   Many efficient algorithms, such as quicksort and merge sort, are based on divide‑and‑conquer techniques.", "gold": [], "notes": "", "candidates": ["GI_C1_1"]}
{"uv_id": "AI09", "resource_id": "R013", "fragment_id": "F013", "fragment_type": "section", "section_title": "Sample Algorithms by Problem", "resource_start_char": 0, "resource_end_char": 429, "text": "Some computational problems have canonical solutions.   For instance, sequential search examines each element in a list until it finds the target, while binary search uses the sorted order of the data to eliminate half of the remaining elements at each step, leading to much faster performance.   Understanding these sample algorithms and their time complexities helps programmers choose the right tool for the problem they face.", "gold": [], "notes": "", "candidates": ["GI_C1_1", "GI_C2_1"]}
{"uv_id": "AI09", "resource_id": "R014", "fragment_id": "F014", "fragment_type": "section", "section_title": "Combinatorial Optimization", "resource_start_char": 0, "resource_end_char": 630, "text": "MIT’s course on combinatorial optimization covers a wide range of topics including cardinality bipartite matching, assignment problems, polyhedral combinatorics, maximum flow and minimum cut, the ellipsoid algorithm, matroids, arborescences, and the traveling salesperson problem.   Students learn how to model combinatorial problems, analyze polytopes arising from linear programming formulations, and design algorithms such as network flow algorithms and matroid intersection.   The course also introduces approximation algorithms for NP‑hard problems and provides insight into theoretical and practical aspects of optimization.", "gold": [{"competency_id": "GI_C5_3", "competency_uri": "http://gamaizer.ia/ontology#GI_C5_3", "label": "Combinatoire et optimisation", "evidence": {"start": 0, "end": 89, "quote": "MIT’s course on combinatorial optimization covers a wide range of topics including cardin"}, "evidence_pattern": "combinatorial"}], "notes": "", "candidates": ["GI_C1_1", "GI_C2_2", "GI_C5_3", "GI_C1_4"]}
{"uv_id": "AI09", "resource_id": "R015", "fragment_id": "F015", "fragment_type": "section", "section_title": "Integer Programming and Combinatorial Optimization", "resource_start_char": 0, "resource_end_char": 543, "text": "This MIT course provides a comprehensive introduction to integer programming and combinatorial optimization.   Organized into four parts, it covers formulations and relaxations of discrete optimization problems, the algebra and geometry of integer optimization, exact algorithms and cutting plane methods, and applications of heuristics and approximation algorithms.   Topics include complexity theory, duality, lattice and algebraic geometry methods, robust discrete optimization, and the design of approximation schemes for NP‑hard problems.", "gold": [{"competency_id": "GI_C5_3", "competency_uri": "http://gamaizer.ia/ontology#GI_C5_3", "label": "Combinatoire et optimisation", "evidence": {"start": 17, "end": 136, "quote": "rovides a comprehensive introduction to integer programming and combinatorial optimization.   Organized into four parts"}, "evidence_pattern": "integer programming"}], "notes": "", "candidates": ["GI_C1_1", "GI_C1_3", "GI_C5_3"]}
